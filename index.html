<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0b0f14;
    --panel:#161b22;
    --muted:#8b949e;
    --accent:#58a6ff;
    --card:#21262d;
    --text:#e6edf3;
    --lobby-width:260px;
    --drawer-duration: 200ms; /* smooth, brisk but not too fast */
    --drawer-ease: cubic-bezier(.16,.84,.24,1);
    --guest-gray: #9aa0a6;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
  #app{width:100%;height:100%;position:relative;overflow:hidden}

/* SETTINGS GEAR (top-right) */
#settingsBtn{position:fixed;top:12px;right:12px;background:transparent;border:0;color:var(--text);font-size:20px;padding:10px;border-radius:10px;cursor:pointer;z-index:90}
.settings-menu{position:fixed;top:52px;right:12px;background:var(--panel);border:1px solid #0d1117;padding:8px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.6);display:none;z-index:91}
.settings-menu.show{display:block}
.settings-menu button{display:block;width:100%;padding:8px 12px;background:transparent;border:0;color:var(--text);text-align:left;border-radius:8px;cursor:pointer}
.settings-menu button:hover{background:rgba(255,255,255,0.03)}

/* PROFILE POPUP */
.profile-pop{position:fixed;background:var(--panel);border:1px solid #0d1117;padding:10px;border-radius:10px;box-shadow:0 10px 40px rgba(0,0,0,0.6);z-index:95;display:none}
.profile-pop.show{display:block}
.profile-pop .row{display:flex;gap:8px;align-items:center;margin-bottom:6px}
.profile-pop .dot{width:34px;height:34px;border-radius:50%;border:2px solid #fff;flex-shrink:0}
.profile-pop .meta{font-size:13px;color:var(--muted)}

/* LOGIN */
#login{position:absolute;inset:0;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:10px;background:var(--bg);z-index:30;padding:20px;}
#login input{padding:12px;border-radius:10px;border:none;background:var(--card);color:var(--text);width:100%;max-width:360px}
#login button{padding:12px 18px;border:none;border-radius:10px;background:var(--accent);color:#000;font-weight:700;cursor:pointer;max-width:360px;width:100%}
#login .small{background:transparent;border:1px solid #333;padding:8px;border-radius:8px;color:var(--muted);cursor:pointer}

/* APP LAYOUT */
#home,#main{position:absolute;inset:0;display:none}
#home{display:flex;flex-direction:row}

/* Lobby (left) */
#homeLeft{width:var(--lobby-width);min-width:120px;background:var(--panel);padding:12px;border-right:1px solid #0d1117;height:100%;overflow:auto;transition:width 200ms ease,transform 220ms cubic-bezier(.2,.9,.3,1);position:relative;}
#homeLeft.collapsed{width:40px;padding:8px}
#lobbyHeader{display:flex;align-items:center;gap:8px;margin-bottom:10px}
#lobbyTitle{flex:1;font-weight:700}
#lobbyUserBtn{background:transparent;border:0;color:var(--text);cursor:pointer;padding:8px;border-radius:8px}
#lobbyUserBtn:hover{background:rgba(255,255,255,0.02)}
.room{padding:10px 12px;border-radius:10px;background:var(--card);margin-bottom:8px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.room:hover{background:var(--accent);color:#000}

/* lobby controls */
#lobbyControls{display:flex;gap:6px;align-items:center;margin-bottom:8px}
.iconbtn{background:transparent;border:0;color:var(--text);padding:6px;border-radius:8px;cursor:pointer}
.iconbtn:active{transform:scale(0.98)}
#lobbySizeBtn{font-weight:700;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.03)}

/* center */
#homeCenter{flex:1;display:flex;flex-direction:column;justify-content:center;align-items:center;position:relative;padding:18px}
#nickRow{display:flex;gap:12px;width:100%;max-width:420px;align-items:center;margin-bottom:20px}
#nick{flex:1;padding:12px;border-radius:10px;border:none;background:var(--card);color:var(--text)}
#nick[readonly]{opacity:0.7}
#nickColorWrapper{width:42px;height:42px;position:relative}
#nickColorCircle{width:100%;height:100%;border-radius:50%;border:2px solid #fff;cursor:pointer}
#createRoom{padding:14px 28px;border-radius:12px;background:var(--accent);color:#000;border:none;font-weight:700;cursor:pointer}

/* MAIN chat */
#main{display:flex;flex-direction:column}
#header{height:56px;background:var(--panel);display:flex;align-items:center;padding:8px 12px;border-bottom:1px solid #0d1117}
#header .left{display:flex;align-items:center;gap:8px}
#roomName{font-weight:700}
#chatWrapper{display:flex;flex:1;overflow:hidden;min-height:0}
#chatSidebar{width:var(--lobby-width);background:var(--panel);border-right:1px solid #0d1117;padding:8px;overflow:auto;transition:width 200ms ease;box-sizing:border-box;}
#chatSidebar.collapsed{width:40px;padding:6px}
#chatWrapperMain{flex:1;display:flex;flex-direction:column;min-height:0}
#chat{flex:1;padding:16px;overflow-y:auto;display:flex;flex-direction:column;gap:10px;background:linear-gradient(180deg,transparent, rgba(255,255,255,0.01));transition:padding-bottom 120ms ease}
.message{display:flex;gap:10px;align-items:flex-start;position:relative}
.message .avatar{width:40px;height:40px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;flex-shrink:0;cursor:pointer}
.msg{background:var(--panel);padding:10px 14px;border-radius:12px;position:relative;max-width:90%}
.time{font-size:11px;color:var(--muted);margin-left:6px}
.reply-btn{position:absolute;right:8px;top:8px;font-size:12px;color:var(--muted);cursor:pointer;opacity:0}
.msg:hover .reply-btn{opacity:1}
.reply-preview{background:rgba(255,255,255,0.02);border-left:3px solid var(--accent);padding:6px;font-size:13px;margin-bottom:8px;border-radius:6px}

/* seen indicator popup (hover) */
.seen-popup{position:absolute;background:var(--card);border:1px solid #0d1117;padding:6px;border-radius:6px;font-size:12px;color:var(--muted);z-index:120;display:none;white-space:nowrap}
.seen-popup.show{display:block}

/* typing indicator (between chat and input) */
#typingIndicator{padding:6px 12px;color:var(--muted);font-size:13px;min-height:18px}

/* input area */
#replyBox{display:none;background:var(--card);padding:8px 14px;font-size:13px;color:var(--text)}
#inputBar{padding:12px;background:var(--panel);border-top:1px solid #0d1117;display:flex;gap:8px;align-items:center}
#msg{flex:1;padding:12px;border-radius:10px;border:none;background:var(--card);color:var(--text)}
#emojiPicker{display:none;flex-wrap:wrap;gap:6px;padding:8px;background:var(--card);border-radius:8px;position:absolute;bottom:72px;left:12px;max-width:320px;max-height:300px;overflow:auto}
#emojiPicker .tabs{display:flex;gap:6px;margin-bottom:8px}
#emojiPicker .tab{padding:6px 8px;border-radius:8px;background:transparent;border:0;color:var(--muted);cursor:pointer}
#emojiPicker .tab.active{background:rgba(255,255,255,0.03);color:var(--text)}
#emojiPicker .gif{width:120px;height:80px;object-fit:cover;border-radius:6px;cursor:pointer}

/* mobile specifics */
.mobile-overlay{position:fixed;inset:0;background:rgba(0,0,0,0);z-index:40;display:none;transition:background var(--drawer-duration) var(--drawer-ease)}
.mobile-overlay.show{display:block;background:rgba(0,0,0,0.45)}
.mobile-lobby-drawer{position:fixed;left:0;top:0;height:100%;width:80%;max-width:340px;background:var(--panel);z-index:50;padding:12px;transform:translateX(-110%);transition:transform var(--drawer-duration) var(--drawer-ease),opacity calc(var(--drawer-duration) * 0.9) var(--drawer-ease);opacity:0;will-change:transform}
.mobile-lobby-drawer.show{transform:translateX(0);opacity:1}
#openLobbyBtn{position:fixed;left:12px;bottom:12px;background:var(--accent);border:none;padding:12px;border-radius:999px;z-index:60;font-weight:800;color:#000;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,0.5)}

/* collapsed small labels */
.collapsed .label-text{display:none}
.collapsed .room{padding:8px;border-radius:8px;text-align:center}

/* responsive */
@media (max-width:900px){:root{--lobby-width:220px}}
@media (max-width:768px){
#home{flex-direction:column}
#homeLeft{display:none} /* desktop lobby hidden on mobile (we use drawer) */
#chatSidebar{display:none}
#header{padding:10px}
#nickRow{max-width:100%}
}

/* fade */
.fade{transition:opacity 180ms ease,transform 180ms ease}
button, .iconbtn{outline: none}

/* scroll to bottom button */
#scrollBottom{position:fixed;right:16px;bottom:88px;background:var(--accent);border:none;padding:10px;border-radius:999px;z-index:80;color:#000;display:none;box-shadow:0 10px 30px rgba(0,0,0,0.5);cursor:pointer}

/* context menu for message (desktop) */
.msg-menu{position:fixed;background:var(--panel);border:1px solid #0d1117;padding:6px;border-radius:8px;display:none;z-index:200}
.msg-menu.show{display:block}
.msg-menu button{display:block;background:transparent;border:0;color:var(--text);padding:6px 10px;width:100%;text-align:left;cursor:pointer;border-radius:6px}
.msg-menu button:hover{background:rgba(255,255,255,0.02)}

/* subtle long-press hint */
.long-press-hint{font-size:12px;color:var(--muted);margin-top:8px;text-align:center}
</style>

</head>
<body>
<div id="app">

  <!-- SETTINGS GEAR -->
  <button id="settingsBtn" title="Settings">‚öôÔ∏è</button>
  <div id="settingsMenu" class="settings-menu" aria-hidden="true">
    <button id="settingsLogout">Logout</button>
    <button id="settingsDelete">Delete user</button>
  </div>

  <!-- PROFILE POPUP -->
  <div id="profilePop" class="profile-pop" role="dialog" aria-hidden="true"></div>

  <!-- LOGIN -->
  <div id="login" aria-hidden="false">
    <input id="loginUser" placeholder="Username" autocomplete="username">
    <input id="loginPass" type="password" placeholder="Password" autocomplete="current-password">
    <button id="loginBtn">Login / Register</button>
    <button id="demoBtn" class="small">Continue as Guest</button>
    <div class="long-press-hint">Long-press a message on mobile to edit/delete. Right-click on desktop.</div>
  </div>

  <!-- HOME -->
  <div id="home">
    <!-- Desktop lobby (keeps desktop visible) -->
    <aside id="homeLeft" aria-label="Lobby">
      <div id="lobbyHeader">
        <div id="lobbyTitle">Rooms</div>
        <div style="display:flex;gap:6px;align-items:center">
          <button id="lobbyUserBtn" title="Profile">Profile ‚ñæ</button>
          <div id="lobbyControls">
            <button id="lobbyToggle" class="iconbtn" title="Collapse/Expand lobby">‚óÄ</button>
            <button id="lobbySizeBtn" class="iconbtn" title="Change lobby size">A</button>
          </div>
        </div>
      </div>
      <div id="roomList"></div>
    </aside>

    <!-- Center -->
    <main id="homeCenter">
      <div id="nickRow">
        <input id="nick" placeholder="Nickname (saved)">
        <div id="nickColorWrapper">
          <div id="nickColorCircle" title="Color"></div>
          <input type="color" id="nickColor" value="#58a6ff" style="position:absolute;opacity:0;left:0;top:0;width:100%;height:100%;">
        </div>
      </div>
      <button id="createRoom">Create / Join Room</button>
      <div style="margin-top:16px;color:var(--muted);font-size:13px;text-align:center;max-width:420px">
        Swipe from the edge to open the room drawer on mobile. Drawer open/close is smooth and fast.
      </div>
    </main>

  </div>

  <!-- MAIN CHAT -->
  <div id="main" aria-hidden="true">
    <div id="header">
      <div class="left">
        <button id="back" class="iconbtn" title="Back">‚Üê</button>
        <div id="roomName">#room</div>
      </div>
      <div style="flex:1"></div>
      <div style="display:flex;gap:8px;align-items:center">
        <!-- header right area left intentionally empty, gear is fixed top-right -->
      </div>
    </div>

    <div id="chatWrapper">
      <aside id="chatSidebar" aria-label="Chat sidebar">
        <div id="chatRoomsHeader" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div style="font-weight:700">Rooms</div>
          <button id="sidebarToggle" class="iconbtn" title="Collapse">‚óÄ</button>
        </div>
        <div id="roomListSidebar"></div>
      </aside>

      <div id="chatWrapperMain">
        <div id="chat"></div>

        <!-- TYPING INDICATOR: appears between chat and input -->
        <div id="typingIndicator" aria-live="polite"></div>

        <div id="replyBox"></div>
        <div id="inputBar">
          <button id="emojiBtn">üòä</button>
          <input id="msg" placeholder="Message... (/clear /delete /roll /coin /tableflip /shrug)" autocomplete="off">
          <div id="emojiPicker"></div>
        </div>
      </div>
    </div>

  </div>

  <!-- Mobile overlay and drawer -->
  <div id="mobileOverlay" class="mobile-overlay" aria-hidden="true"></div>
  <div id="mobileDrawer" class="mobile-lobby-drawer" aria-hidden="true">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div style="font-weight:700">Rooms</div>
      <button id="closeDrawer" class="iconbtn">‚úï</button>
    </div>
    <div id="roomListMobile"></div>
  </div>

  <!-- Blue three-line button (mobile) -->
  <button id="openLobbyBtn" title="Open lobby">‚ò∞</button>

  <!-- scroll to bottom -->
  <button id="scrollBottom" title="Scroll to bottom">‚Üì</button>

  <!-- msg context menu -->
  <div id="msgMenu" class="msg-menu" role="menu"></div>

  <!-- seen popup -->
  <div id="seenPopup" class="seen-popup"></div>

</div>

<script type="module">
/* ===================
   Full updated app logic with requested features:
   - Guests have permanent gray color (uneditable)
   - Profile card popup (click name/avatar) showing color, joined, message count
   - Settings dropdown (top-right) already present
   - Edit/Delete own messages (long-press on mobile, right-click on desktop)
   - Swipe reply on mobile (drag message right -> reply)
   - Remove reply button on mobile (only gesture)
   - Floating scroll-to-bottom button both mobile & desktop
   - Links in messages clickable
   - GIF picker tab in emoji picker
   - Hover (not own message) shows who has seen it
   - Slash commands: /roll, /roll N, /coin, /tableflip, /shrug
   - All code provided in one file
   =================== */

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import {
  getFirestore, doc, getDoc, setDoc, collection,
  addDoc, getDocs, query, orderBy,
  onSnapshot, serverTimestamp, deleteDoc, updateDoc, where
} from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

/* Firebase init - same as before */
const firebaseConfig = {
  apiKey:"AIzaSyDbYLUXJjHQ-V5uFvtyzwq-IwIKM7xTcyc",
  projectId:"chat-fc8ef"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

/* DOM refs */
const login = document.getElementById('login');
const home = document.getElementById('home');
const main = document.getElementById('main');
const loginBtn = document.getElementById('loginBtn');
const demoBtn = document.getElementById('demoBtn');
const loginUser = document.getElementById('loginUser');
const loginPass = document.getElementById('loginPass');

const roomList = document.getElementById('roomList');
const roomListSidebar = document.getElementById('roomListSidebar');
const roomListMobile = document.getElementById('roomListMobile');

const createRoomBtn = document.getElementById('createRoom');
const nickInput = document.getElementById('nick');
const nickColorInput = document.getElementById('nickColor');
const nickColorCircle = document.getElementById('nickColorCircle');

const lobby = document.getElementById('homeLeft');
const lobbyToggle = document.getElementById('lobbyToggle');
const lobbySizeBtn = document.getElementById('lobbySizeBtn');

const chatSidebar = document.getElementById('chatSidebar');
const sidebarToggle = document.getElementById('sidebarToggle');

const openLobbyBtn = document.getElementById('openLobbyBtn');
const mobileOverlay = document.getElementById('mobileOverlay');
const mobileDrawer = document.getElementById('mobileDrawer');
const closeDrawer = document.getElementById('closeDrawer');

const chat = document.getElementById('chat');
const chatWrapperMain = document.getElementById('chatWrapperMain');
const msg = document.getElementById('msg');
const replyBox = document.getElementById('replyBox');
const roomName = document.getElementById('roomName');
const emojiPicker = document.getElementById('emojiPicker');
const emojiBtn = document.getElementById('emojiBtn');
const typingIndicator = document.getElementById('typingIndicator');
const back = document.getElementById('back');

const settingsBtn = document.getElementById('settingsBtn');
const settingsMenu = document.getElementById('settingsMenu');
const settingsLogout = document.getElementById('settingsLogout');
const settingsDelete = document.getElementById('settingsDelete');

const profilePop = document.getElementById('profilePop');
const lobbyUserBtn = document.getElementById('lobbyUserBtn');

const mobileOverlayEl = mobileOverlay;
const scrollBottomBtn = document.getElementById('scrollBottom');
const msgMenu = document.getElementById('msgMenu');
const seenPopup = document.getElementById('seenPopup');

let users = JSON.parse(localStorage.getItem('users')||'{}');
let nick = '';
let nickColor = localStorage.getItem('nickColor')||'#58a6ff';
let room = '';
let replyTo = null;
let lastMessageTime = 0;
let typingTimeout = null;
let messagesUnsub = null;
let typingUnsub = null;
let presenceUnsub = null;
let messagesCache = {}; // id -> data for hover etc
let editingMessageId = null;

/* Device detection */
const isTouch = matchMedia('(pointer:coarse)').matches;
const isMobile = /Mobi|Android|iPhone|iPad|Windows Phone/.test(navigator.userAgent) || isTouch;

/* UI init */
nickColorInput.value = nickColor;
nickColorCircle.style.background = nickColor;
nickInput.value = localStorage.getItem('nick') || '';

/* Notification permission */
if("Notification" in window && Notification.permission !== 'granted'){
  Notification.requestPermission().catch(()=>{});
}

/* Ensure desktop lobby visible and cannot be collapsed */
function enforceDesktopLobby(){
  if(!isMobile){
    lobby.style.display = 'block';
    chatSidebar.style.display = 'block';
    if(lobbyToggle) lobbyToggle.style.display = 'none';
    if(sidebarToggle) sidebarToggle.style.display = 'none';
  } else {
    lobby.style.display = 'none';
    chatSidebar.style.display = 'none';
  }
}
enforceDesktopLobby();

/* Session helpers */
function showHome(){
  login.style.display = 'none';
  home.style.display = 'flex';
  main.style.display = 'none';
  updateOpenLobbyBtnVisibility();
  updateNickEditable();
}
function showLogin(){
  login.style.display = 'flex';
  home.style.display = 'none';
  main.style.display = 'none';
  localStorage.removeItem('session');
  updateOpenLobbyBtnVisibility();
  updateNickEditable();
}
function showMain(){
  login.style.display = 'none';
  home.style.display = 'none';
  main.style.display = 'flex';
  updateOpenLobbyBtnVisibility();
  updateNickEditable();
}

/* restore session */
if(localStorage.getItem('session')) showHome();
else showLogin();

/* update whether nickname is editable (guest cannot change) */
function updateNickEditable(){
  const session = localStorage.getItem('session') || '';
  if(session.startsWith('Guest')){
    nickInput.readOnly = true;
    nickColorInput.disabled = true;
    nickColorCircle.style.pointerEvents = 'none';
    nickInput.title = "Guest name cannot be changed";
    // force guest gray color
    nickColorInput.value = getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim() || '#9aa0a6';
    nickColorCircle.style.background = nickColorInput.value;
    localStorage.setItem('nickColor', nickColorInput.value);
  } else {
    nickInput.readOnly = false;
    nickColorInput.disabled = false;
    nickColorCircle.style.pointerEvents = 'auto';
    nickInput.title = "";
    nickColorInput.value = localStorage.getItem('nickColor') || '#58a6ff';
    nickColorCircle.style.background = nickColorInput.value;
  }
}

/* login */
loginBtn.onclick = () => {
  const u = loginUser.value.trim();
  const p = loginPass.value;
  if(!u || !p) return alert('Please fill both fields');
  if(users[u] && users[u] !== p) return alert('Incorrect password');
  users[u] = p;
  localStorage.setItem('users',JSON.stringify(users));
  localStorage.setItem('session',u);
  nickInput.value = u;
  localStorage.setItem('nick', u);
  showHome();
};
demoBtn.onclick = () => {
  const guest = 'Guest' + Math.floor(Math.random()*10000);
  localStorage.setItem('session', guest);
  nickInput.value = guest;
  localStorage.setItem('nick', guest);
  showHome();
};

/* SETTINGS menu (gear) */
settingsBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  const open = settingsMenu.classList.toggle('show');
  settingsMenu.setAttribute('aria-hidden', !open);
});
settingsMenu.addEventListener('click', (e) => e.stopPropagation());
document.addEventListener('click', () => {
  if(settingsMenu.classList.contains('show')){
    settingsMenu.classList.remove('show');
    settingsMenu.setAttribute('aria-hidden','true');
  }
  hideProfile();
  hideMsgMenu();
  hideSeenPopup();
});

/* Logout via settings */
settingsLogout.addEventListener('click', () => {
  settingsMenu.classList.remove('show');
  localStorage.removeItem('session');
  showLogin();
});

/* Delete user via settings */
settingsDelete.addEventListener('click', () => {
  settingsMenu.classList.remove('show');
  const session = localStorage.getItem('session');
  if(!session){ alert('No logged-in user'); return; }
  if(session.startsWith('Guest')){ alert('Guest account cannot be deleted.'); return; }
  if(!confirm(`Delete user "${session}" and its saved credentials? This cannot be undone.`)) return;
  try{
    users = JSON.parse(localStorage.getItem('users')||'{}');
    delete users[session];
    localStorage.setItem('users', JSON.stringify(users));
  }catch(e){}
  localStorage.removeItem('session');
  localStorage.removeItem('nick');
  showLogin();
});

/* nick color */
nickColorCircle.addEventListener('click', ()=> {
  if(nickColorInput.disabled) return;
  nickColorInput.click();
});
nickColorInput.addEventListener('input', ()=> {
  nickColorCircle.style.background = nickColorInput.value;
  localStorage.setItem('nickColor', nickColorInput.value);
});

/* rooms load/render */
async function loadRooms(){
  roomList.innerHTML = '';
  roomListSidebar.innerHTML = '';
  roomListMobile.innerHTML = '';
  try{
    const s = await getDocs(collection(db,'rooms'));
    s.forEach(r => renderRoomEntry(r.id));
  }catch(e){ console.error('loadRooms error', e); }
}
function renderRoomEntry(id){
  const createEl = (container) => {
    const d = document.createElement('div');
    d.className = 'room';
    d.textContent = '# ' + id;
    d.onclick = ()=> joinRoom(id);
    container.appendChild(d);
  };
  createEl(roomList);
  createEl(roomListSidebar);
  createEl(roomListMobile);
}

/* create/join handlers */
createRoomBtn.onclick = async ()=> {
  const r = prompt('Room name'); if(!r) return;
  const p = prompt('Password (optional)');
  const ref = doc(db,'rooms',r);
  const snap = await getDoc(ref);
  if(!snap.exists()) await setDoc(ref,{password:p||'',created:serverTimestamp()});
  joinRoom(r);
};

/* joinRoom handles mobile drawer smooth close when applicable, then calls enterRoom */
async function joinRoom(r){
  const ref = doc(db,'rooms',r);
  const snap = await getDoc(ref);
  if(!snap.exists()) return alert("Room not found");
  const pass = prompt('Password');
  if(pass !== snap.data().password) return alert('Incorrect room password');

  // Save nick/color
  nick = nickInput.value || ('Anon'+Math.floor(Math.random()*1000));
  // enforce guest color if guest
  const session = localStorage.getItem('session') || '';
  if(session.startsWith('Guest')) {
    nickColorInput.value = getComputedStyle(document.documentElement).getPropertyValue('--guest-gray').trim() || '#9aa0a6';
  }
  nickColor = nickColorInput.value;
  localStorage.setItem('nick', nick);
  localStorage.setItem('nickColor', nickColor);

  // If mobile & drawer open -> animate drawer close smoothly, THEN enter room
  const durationMs = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--drawer-duration')) || 200;
  const drawerOpen = mobileDrawer.classList.contains('show');
  if(isMobile && drawerOpen){
    mobileDrawer.classList.remove('show');
    mobileOverlay.classList.remove('show');
    setTimeout(()=> {
      mobileOverlay.style.display = 'none';
      mobileDrawer.style.display = 'none';
      enterRoom(r);
      updateOpenLobbyBtnVisibility();
    }, durationMs + 20);
  } else {
    enterRoom(r);
  }
}

/* enterRoom performs the actual subscription and view switch */
async function enterRoom(r){
  // show main immediately
  showMain();
  room = r;
  roomName.textContent = '# ' + r;
  chat.innerHTML = '';
  messagesCache = {};

  // cleanup previous listeners
  if(messagesUnsub) messagesUnsub();
  if(typingUnsub) typingUnsub();
  if(presenceUnsub) presenceUnsub();

  // mark presence: joined timestamp & lastSeen
  nick = nickInput.value || ('Anon'+Math.floor(Math.random()*1000));
  nickColor = nickColorInput.value;
  try{
    await setDoc(doc(db,'rooms',room,'presence',nick), { joined: serverTimestamp(), lastSeen: serverTimestamp(), color: nickColor }, { merge: true });
  }catch(e){ console.warn('presence set failed', e); }

  // messages snapshot
  const msgsQuery = query(collection(db,'rooms',room,'messages'), orderBy('time'));
  messagesUnsub = onSnapshot(msgsQuery, snap => {
    chat.innerHTML = '';
    snap.forEach(d => {
      const m = d.data();
      messagesCache[d.id] = { id: d.id, ...m };
      const t = m.time?.toMillis?.() || 0;
      // notifications
      if(t > lastMessageTime && document.hidden && m.name !== nick && "Notification" in window && Notification.permission === "granted"){
        new Notification('# '+room, { body: `${m.name}: ${m.text}` });
      }
      lastMessageTime = Math.max(lastMessageTime, t);

      const el = renderMessageElement(d.id, m, t);
      chat.appendChild(el);
    });
    scrollChatToBottom();
  });

  // typing snapshot
  typingUnsub = onSnapshot(collection(db,'rooms',room,'typing'), snap => {
    const now = Date.now();
    const usersTyping = [];
    snap.forEach(d=>{
      const t = d.data().t?.toMillis?.() ?? d.data().t;
      if(d.id !== nick && t && now - t < 2000) usersTyping.push(d.id);
    });
    typingIndicator.textContent = usersTyping.length ? usersTyping.join(', ') + ' is typing...' : '';
  });

  // presence listener
  presenceUnsub = onSnapshot(collection(db,'rooms',room,'presence'), snap => {
    // keep presence available for hover checks
  });

  // auto update lastSeen periodically while viewing
  setInterval(()=> {
    if(room && nick) setDoc(doc(db,'rooms',room,'presence',nick), { lastSeen: serverTimestamp(), color: nickColor }, { merge: true }).catch(()=>{});
  }, 5000);
}

/* Helper: render a message DOM element */
function renderMessageElement(id, m, t){
  const wrapper = document.createElement('div');
  wrapper.className = 'message';
  wrapper.dataset.id = id;

  // avatar
  const av = document.createElement('div');
  av.className = 'avatar';
  av.style.background = m.color || '#ddd';
  av.textContent = (m.name && m.name[0]) || '?';
  av.title = m.name || '';
  av.addEventListener('click', (e)=> {
    e.stopPropagation();
    showProfile(m.name);
  });

  // message box
  const box = document.createElement('div');
  box.className = 'msg';
  box.innerHTML = `
    ${m.reply?`<div class="reply-preview"><b>${escapeHtml(m.reply.name)}</b>: ${escapeHtml(m.reply.text)}</div>`:''}
    <b class="msg-name" style="color:${m.color||'#fff'};cursor:pointer">${escapeHtml(m.name)}</b>
    <span class="time">${t?new Date(t).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}):''}</span>
    <div class="msg-text">${linkify(escapeHtml(m.text))}</div>
  `;

  // On click name -> profile as well
  box.querySelector('.msg-name').addEventListener('click', (e)=> {
    e.stopPropagation();
    showProfile(m.name);
  });

  // reply button for desktop only (mobile uses swipe)
  if(!isMobile){
    const rbtn = document.createElement('div');
    rbtn.className = 'reply-btn';
    rbtn.textContent = 'reply';
    rbtn.addEventListener('click', ()=> {
      replyTo = { name: m.name, text: m.text };
      replyBox.style.display = 'block';
      replyBox.innerHTML = `Replying to <b>${escapeHtml(replyTo.name)}</b> <button id="cancelReply" style="margin-left:8px">x</button>`;
      document.getElementById('cancelReply').onclick = cancelReply;
    });
    box.appendChild(rbtn);
  }

  // context menu (desktop) -> edit/delete own messages
  box.addEventListener('contextmenu', (ev)=>{
    ev.preventDefault();
    ev.stopPropagation();
    const menuItems = [];
    if(m.name === nick){
      menuItems.push({ label: 'Edit', action: ()=> startEditMessage(id, m) });
      menuItems.push({ label: 'Delete', action: ()=> deleteMessage(id, m) });
    }
    menuItems.push({ label: 'Reply', action: ()=> { replyTo = { name: m.name, text: m.text }; replyBox.style.display='block'; replyBox.innerHTML = `Replying to <b>${escapeHtml(replyTo.name)}</b> <button id="cancelReply" style="margin-left:8px">x</button>`; document.getElementById('cancelReply').onclick = cancelReply; }});
    showMsgMenuAt(ev.clientX, ev.clientY, menuItems);
  });

  // long-press on mobile for edit/delete + swipe to reply
  if(isMobile){
    // long press for options
    let pressTimer = null;
    box.addEventListener('touchstart', (e)=>{
      pressTimer = setTimeout(()=> {
        if(m.name === nick){
          const ok = confirm('Edit or delete this message?\nPress OK to edit, Cancel to delete.');
          if(ok) startEditMessage(id, m);
          else deleteMessage(id, m);
        } else {
          alert('You can only edit/delete your own messages.');
        }
      }, 600);
    }, {passive:true});
    box.addEventListener('touchend', ()=> { if(pressTimer) clearTimeout(pressTimer); });

    // swipe -> reply (rightwards swipe to reply)
    let sx=0, sy=0, sw=false;
    box.addEventListener('touchstart', (e)=> { const t=e.touches[0]; sx = t.clientX; sy=t.clientY; sw=false; }, {passive:true});
    box.addEventListener('touchmove', (e)=> {
      const t=e.touches[0];
      const dx = t.clientX - sx;
      const dy = t.clientY - sy;
      if(Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)){
        if(dx > 40){ // swipe right to reply
          sw = true;
          replyTo = { name: m.name, text: m.text };
          replyBox.style.display = 'block';
          replyBox.innerHTML = `Replying to <b>${escapeHtml(replyTo.name)}</b> <button id="cancelReply" style="margin-left:8px">x</button>`;
          document.getElementById('cancelReply').onclick = cancelReply;
        }
      }
    }, {passive:true});
  }

  // hover: show who has seen (for non-own messages)
  box.addEventListener('mouseenter', async (ev)=>{
    if(m.name === nick) return;
    const pos = ev;
    const seen = await computeSeenByForMessage(m.time?.toMillis?.() || 0);
    if(seen.length){
      showSeenPopupAt(pos.clientX, pos.clientY, seen);
    }
  });
  box.addEventListener('mouseleave', ()=> hideSeenPopup());

  wrapper.appendChild(av);
  wrapper.appendChild(box);
  return wrapper;
}

/* show message context menu at position */
function showMsgMenuAt(x,y,items){
  msgMenu.innerHTML = '';
  items.forEach(it=>{
    const b = document.createElement('button');
    b.textContent = it.label;
    b.onclick = (e)=> { e.stopPropagation(); it.action(); hideMsgMenu(); };
    msgMenu.appendChild(b);
  });
  msgMenu.style.left = x + 'px';
  msgMenu.style.top = y + 'px';
  msgMenu.classList.add('show');
}
function hideMsgMenu(){ msgMenu.classList.remove('show'); msgMenu.style.left=''; msgMenu.style.top=''; }

/* show/hide profile popup */
async function showProfile(username){
  // get presence doc to read joined time
  const pDoc = await getDoc(doc(db,'rooms',room,'presence',username)).catch(()=>null);
  let joinedStr = 'Unknown';
  let color = '#999';
  if(pDoc && pDoc.exists()){
    const data = pDoc.data();
    color = data.color || color;
    const j = data.joined?.toMillis?.();
    if(j) joinedStr = new Date(j).toLocaleString();
  }
  // message count
  let count = 0;
  try{
    const q = query(collection(db,'rooms',room,'messages'), where('name','==',username));
    const s = await getDocs(q);
    count = s.size;
  }catch(e){}

  profilePop.innerHTML = `
    <div class="row"><div class="dot" style="background:${color}"></div><div><div style="font-weight:700">${escapeHtml(username)}</div><div class="meta">${count} messages</div></div></div>
    <div class="meta">Joined: ${joinedStr}</div>
    <div style="height:6px"></div>
    <div><button id="closeProfileBtn" class="iconbtn">Close</button></div>
  `;
  profilePop.classList.add('show');
  profilePop.setAttribute('aria-hidden','false');
  const rect = document.querySelector('#header')?.getBoundingClientRect();
  profilePop.style.right = '12px';
  profilePop.style.top = (rect ? rect.bottom + 8 : 70) + 'px';
  document.getElementById('closeProfileBtn').onclick = hideProfile;
}
function hideProfile(){ profilePop.classList.remove('show'); profilePop.setAttribute('aria-hidden','true'); }

/* compute who has seen a message (presence lastSeen > messageTime) */
async function computeSeenByForMessage(messageTimeMs){
  if(!room) return [];
  try{
    const s = await getDocs(collection(db,'rooms',room,'presence'));
    const seenBy = [];
    s.forEach(d=>{
      const p = d.data();
      const t = p.lastSeen?.toMillis?.();
      if(t && t >= messageTimeMs) seenBy.push(d.id);
    });
    // exclude author and maybe local
    return seenBy.filter(n => n !== undefined && n !== null && n !== '');
  }catch(e){ return []; }
}

/* seen popup */
function showSeenPopupAt(x,y,list){
  seenPopup.textContent = list.join(', ') + ' saw this';
  seenPopup.style.left = (x + 8) + 'px';
  seenPopup.style.top = (y + 8) + 'px';
  seenPopup.classList.add('show');
}
function hideSeenPopup(){ seenPopup.classList.remove('show'); }

/* typing indicator management */
msg.addEventListener('input', ()=> {
  if(!room || !nick) return;
  if(msg.value.trim()===''){
    deleteDoc(doc(db,'rooms',room,'typing',nick)).catch(()=>{});
    return;
  }
  setDoc(doc(db,'rooms',room,'typing',nick),{t:serverTimestamp()}).catch(()=>{});
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(()=> { deleteDoc(doc(db,'rooms',room,'typing',nick)).catch(()=>{}); }, 1500);
});
msg.addEventListener('blur', ()=> { if(room && nick) deleteDoc(doc(db,'rooms',room,'typing',nick)).catch(()=>{}); });

/* reply UI */
chat.addEventListener('click', (e)=> {
  const b = e.target.closest('.reply-btn');
  if(!b) return;
  replyTo = { name: b.dataset.name, text: b.dataset.text }; // not used here; left for compatibility
});

/* cancel reply */
function cancelReply(){ replyTo = null; replyBox.style.display = 'none'; }

/* send messages / commands / edit handling */
msg.addEventListener('keydown', async (e)=> {
  if(e.key !== 'Enter') return;
  const textRaw = msg.value.trim(); msg.value = ''; if(!textRaw) return;
  if(!room){ alert('You are not in a room'); return; }
  deleteDoc(doc(db,'rooms',room,'typing',nick)).catch(()=>{});

  // commands
  if(textRaw.startsWith('/')){
    const out = handleCommand(textRaw);
    await addDoc(collection(db,'rooms',room,'messages'), {
      name: nick, text: out, reply: replyTo, color: nickColorInput.value, time: serverTimestamp()
    }).catch(console.error);
    replyTo = null; replyBox.style.display = 'none';
    return;
  }

  // editing
  if(editingMessageId){
    // update message doc
    try{
      await updateDoc(doc(db,'rooms',room,'messages',editingMessageId), { text: textRaw, edited: true });
    }catch(e){ console.error('edit failed', e); }
    editingMessageId = null;
    replyTo = null; replyBox.style.display = 'none';
    return;
  }

  // normal send
  await addDoc(collection(db,'rooms',room,'messages'), {
    name: nick, text: textRaw, reply: replyTo, color: nickColorInput.value, time: serverTimestamp()
  }).catch(console.error);
  replyTo = null; replyBox.style.display = 'none';
});

/* command handler */
function handleCommand(input){
  const parts = input.trim().split(/\s+/);
  const cmd = parts[0].toLowerCase();
  if(cmd === '/roll'){
    let n = 1;
    if(parts[1] && /^\d+$/.test(parts[1])) n = Math.min(10, Math.max(1, parseInt(parts[1],10)));
    const rolls = [];
    for(let i=0;i<n;i++) rolls.push(1 + Math.floor(Math.random()*6));
    if(n===1) return `${nick} rolled üé≤ ${rolls[0]}`;
    return `${nick} rolled ` + rolls.map(r=>`üé≤ ${r}`).join(' + ') + ` = ${rolls.reduce((a,b)=>a+b,0)}`;
  } else if(cmd === '/coin'){
    return `${nick} flipped a coin: ${Math.random() < 0.5 ? 'Heads' : 'Tails'}`;
  } else if(cmd === '/tableflip'){
    return '(‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª';
  } else if(cmd === '/shrug'){
    return '¬Ø\\_(„ÉÑ)_/¬Ø';
  } else if(cmd === '/clear'){
    // performed client-side in previous version; keep quick server-side delete of messages
    // WARNING: Dangerous; require permission check. We'll perform local delete attempt of messages (not ideal).
    (async()=>{
      try{
        const msgs = await getDocs(collection(db,'rooms',room,'messages'));
        for(const d of msgs.docs){ await deleteDoc(d.ref).catch(()=>{}); }
      }catch(e){}
    })();
    return `${nick} cleared the chat`;
  }
  return input;
}

/* emojis + GIF picker */
const emojiList = [
"üòÄ","üòÉ","üòÑ","üòÅ","üòÜ","üòÇ","ü§£","üôÇ","üôÉ","üòâ","üòä","üòá",
"üòç","ü•∞","üòò","üòó","üòô","üòö","üòã","üòõ","üòú","ü§™","üòù",
"ü§ó","ü§≠","ü§´","ü§î","ü§®","üòê","üòë","üò∂","üôÑ","üòè",
"üò£","üò•","üòÆ","üòØ","üò≤","üò™","üò´","ü•±","üò¥","üòå",
"üò§","üò†","üò°","ü§¨","üò¢","üò≠","ü•∫","üò≥","üò±","üò®","üò∞","üòì",
"üëç","üëé","üëå","‚úåÔ∏è","ü§û","ü§ü","ü§ò","ü§ô","üëã","üëè","üôå","üôè",
"‚ù§Ô∏è","üß°","üíõ","üíö","üíô","üíú","üñ§","ü§ç","ü§é","üíî","üíï","üíû","üíì","üíó","üíñ",
"üî•","üíØ","‚ú®","‚≠ê","üåü","‚ö°","üéâ","üéä","üéà","üé∂","üéµ"
];
const gifList = [
  // a few publicly hosted GIFs (examples) ‚Äî replace or expand in production
  'https://media.giphy.com/media/3o6Zt6ML6BklcajjsA/giphy.gif',
  'https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif',
  'https://media.giphy.com/media/13HgwGsXF0aiGY/giphy.gif',
  'https://media.giphy.com/media/26BRv0ThflsHCqDrG/giphy.gif'
];

function buildEmojiPicker(){
  emojiPicker.innerHTML = '';
  const tabs = document.createElement('div'); tabs.className='tabs';
  const t1 = document.createElement('button'); t1.className='tab active'; t1.textContent='Emoji';
  const t2 = document.createElement('button'); t2.className='tab'; t2.textContent='GIFs';
  tabs.appendChild(t1); tabs.appendChild(t2);
  emojiPicker.appendChild(tabs);

  const content = document.createElement('div'); content.className='content';
  const emojiGrid = document.createElement('div'); emojiGrid.style.display='flex'; emojiGrid.style.flexWrap='wrap';
  emojiList.forEach(e => {
    const d = document.createElement('div'); d.textContent = e; d.style.cursor='pointer'; d.style.padding='6px'; d.style.fontSize='20px';
    d.onclick = ()=> { msg.value += e; emojiPicker.style.display='none'; msg.focus(); };
    emojiGrid.appendChild(d);
  });
  content.appendChild(emojiGrid);

  const gifGrid = document.createElement('div'); gifGrid.style.display='none'; gifGrid.style.gap='6px';
  gifList.forEach(url=>{
    const g = document.createElement('img'); g.src=url; g.className='gif';
    g.onclick = ()=> { msg.value += ' ' + url; emojiPicker.style.display='none'; msg.focus(); };
    gifGrid.appendChild(g);
  });
  content.appendChild(gifGrid);

  t1.onclick = ()=> { t1.classList.add('active'); t2.classList.remove('active'); emojiGrid.style.display='flex'; gifGrid.style.display='none'; };
  t2.onclick = ()=> { t2.classList.add('active'); t1.classList.remove('active'); emojiGrid.style.display='none'; gifGrid.style.display='flex'; };

  emojiPicker.appendChild(content);
}
buildEmojiPicker();
emojiBtn.onclick = ()=> emojiPicker.style.display = emojiPicker.style.display === 'flex' ? 'none' : 'flex';

/* back button */
back.onclick = ()=> {
  if(messagesUnsub) messagesUnsub();
  if(typingUnsub) typingUnsub();
  if(presenceUnsub) presenceUnsub();
  showHome();
  room = '';
  chat.innerHTML = '';
  typingIndicator.textContent = '';
};

/* lobby size (kept) */
const LOBBY_SIZES = [
  {name:'small', width:'120px'},
  {name:'normal', width:'260px'},
  {name:'large', width:'360px'}
];
let lobbySizeIndex = parseInt(localStorage.getItem('lobbySizeIndex')||'1',10);
applyLobbySize();

lobbySizeBtn.addEventListener('click', ()=> {
  lobbySizeIndex = (lobbySizeIndex + 1) % LOBBY_SIZES.length;
  applyLobbySize();
  localStorage.setItem('lobbySizeIndex', lobbySizeIndex);
});
function applyLobbySize(){
  const s = LOBBY_SIZES[lobbySizeIndex];
  document.documentElement.style.setProperty('--lobby-width', s.width);
  lobbySizeBtn.textContent = s.name[0].toUpperCase();
  if(isMobile) {
    const collapse = (s.name === 'small');
    lobby.classList.toggle('collapsed', collapse);
    chatSidebar.classList.toggle('collapsed', collapse);
  } else {
    lobby.classList.remove('collapsed');
    chatSidebar.classList.remove('collapsed');
  }
}

/* Mobile drawer open/close smooth functions */
function openMobileDrawer(){
  mobileOverlay.classList.add('show');
  mobileDrawer.classList.add('show');
  mobileOverlay.style.display = 'block';
  mobileDrawer.style.display = 'block';
  mobileOverlay.setAttribute('aria-hidden','false'); mobileDrawer.setAttribute('aria-hidden','false');
  updateOpenLobbyBtnVisibility();
}
function closeMobileDrawer(){
  mobileDrawer.classList.remove('show');
  mobileOverlay.classList.remove('show');
  const durationMs = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--drawer-duration')) || 200;
  setTimeout(()=> {
    if(!mobileDrawer.classList.contains('show')){
      mobileOverlay.style.display = 'none';
      mobileDrawer.style.display = 'none';
      mobileOverlay.setAttribute('aria-hidden','true'); mobileDrawer.setAttribute('aria-hidden','true');
      updateOpenLobbyBtnVisibility();
    }
  }, durationMs + 20);
}

/* Visibility logic for blue button (mobile) */
function updateOpenLobbyBtnVisibility(){
  const drawerOpen = mobileDrawer.classList.contains('show') || mobileOverlay.classList.contains('show');
  if(!isMobile){
    openLobbyBtn.style.display = 'none'; return;
  }
  const isHomeVisible = home.style.display !== 'none';
  if(isHomeVisible && !drawerOpen) openLobbyBtn.style.display = 'block';
  else openLobbyBtn.style.display = 'none';
}
const origShowHome = showHome;
showHome = function(){ origShowHome(); updateOpenLobbyBtnVisibility(); };
const origShowMain = showMain;
showMain = function(){ origShowMain(); updateOpenLobbyBtnVisibility(); };
const origShowLogin = showLogin;
showLogin = function(){ origShowLogin(); updateOpenLobbyBtnVisibility(); };

/* Fast drag + velocity-based flick for drawer */
let dragging = false;
let startX = 0;
let lastX = 0;
let lastT = 0;
let vx = 0;
let drawerWidth = 0;
const EDGE_ZONE = 36;
const SHORT_THRESHOLD = 30;
const VELOCITY_THRESHOLD = 0.35;
let touchStarted = false;
let touchStartX = 0;
let touchStartY = 0;
let touchPotentialDrag = false;

function beginDrag(x, initiallyOpen){
  dragging = true;
  startX = x;
  lastX = x;
  lastT = performance.now();
  drawerWidth = mobileDrawer.getBoundingClientRect().width || (window.innerWidth * 0.8);
  mobileDrawer.style.transition = 'none';
  mobileOverlay.style.transition = 'none';
  if(!mobileOverlay.classList.contains('show')) mobileOverlay.style.display = 'block';
  if(!mobileDrawer.classList.contains('show')) mobileDrawer.style.display = 'block';
  mobileDrawer.classList.remove('show');
}
function dragMove(x){
  if(!dragging) return;
  const dx = x - startX;
  const wasOpen = mobileDrawer.classList.contains('show');
  let translate;
  if(wasOpen) translate = Math.min(0, dx);
  else translate = Math.max(-drawerWidth, -drawerWidth + dx);
  if(translate > 0) translate = 0;
  if(translate < -drawerWidth) translate = -drawerWidth;
  mobileDrawer.style.transform = `translateX(${translate}px)`;
  const openness = 1 - (Math.abs(translate) / drawerWidth);
  mobileOverlay.style.background = `rgba(0,0,0,${0.45 * openness})`;
  mobileOverlay.style.display = 'block';
  const now = performance.now();
  const dt = now - lastT || 16;
  vx = (x - lastX) / dt;
  lastX = x;
  lastT = now;
}
function endDrag(){
  if(!dragging) return;
  dragging = false;
  const style = window.getComputedStyle(mobileDrawer);
  let translateX = 0;
  const m = mobileDrawer.style.transform.match(/translateX\((-?\d+(\.\d+)?)px\)/);
  translateX = m ? parseFloat(m[1]) : 0;
  const wasOpen = mobileDrawer.classList.contains('show');
  const openDecision = (() => {
    if(Math.abs(vx) > VELOCITY_THRESHOLD) return vx > 0;
    if(wasOpen) return !(Math.abs(translateX) > SHORT_THRESHOLD);
    else return (Math.abs(translateX) < (drawerWidth - SHORT_THRESHOLD));
  })();
  mobileDrawer.style.transition = '';
  mobileOverlay.style.transition = '';
  if(openDecision){
    mobileDrawer.style.transform = '';
    mobileDrawer.classList.add('show');
    mobileOverlay.classList.add('show');
    updateOpenLobbyBtnVisibility();
  } else {
    mobileDrawer.style.transform = `translateX(-${drawerWidth}px)`;
    mobileDrawer.classList.remove('show');
    mobileOverlay.classList.remove('show');
    setTimeout(()=> {
      if(!mobileDrawer.classList.contains('show')){
        mobileOverlay.style.display = 'none';
        mobileDrawer.style.display = 'none';
        updateOpenLobbyBtnVisibility();
      }
    }, 220);
  }
  vx = 0;
  mobileDrawer.style.willChange = '';
}

/* touch handlers for drag */
document.addEventListener('touchstart', (e)=> {
  if(!isMobile) return;
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
  touchStarted = true;
  touchPotentialDrag = false;
  const drawerOpen = mobileDrawer.classList.contains('show');
  const isHomeVisible = home.style.display !== 'none';
  if(drawerOpen || (isHomeVisible && touchStartX <= EDGE_ZONE)){
    touchPotentialDrag = true;
  }
}, {passive:true});

document.addEventListener('touchmove', (e)=> {
  if(!isMobile || !touchStarted) return;
  const t = e.touches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  if(Math.abs(dy) > Math.abs(dx) + 8){
    if(dragging) endDrag();
    touchStarted = false;
    touchPotentialDrag = false;
    return;
  }
  if(!dragging){
    if(touchPotentialDrag && Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)){
      const drawerOpen = mobileDrawer.classList.contains('show');
      beginDrag(t.clientX, drawerOpen);
      dragMove(t.clientX);
      return;
    } else {
      return;
    }
  }
  if(dragging) dragMove(t.clientX);
}, {passive:true});

document.addEventListener('touchend', (e)=> {
  if(!isMobile) return;
  if(dragging){
    endDrag();
  }
  touchStarted = false;
  touchPotentialDrag = false;
});

/* overlay / button events */
openLobbyBtn.addEventListener('click', openMobileDrawer);
mobileOverlay.addEventListener('click', closeMobileDrawer);
closeDrawer.addEventListener('click', closeMobileDrawer);

/* keyboard handling using visualViewport */
function onViewportResize(){
  const vv = window.visualViewport;
  let keyboardHeight = 0;
  if(vv){
    keyboardHeight = window.innerHeight - vv.height - (vv.offsetTop || 0);
    if(keyboardHeight < 0) keyboardHeight = 0;
  } else {
    keyboardHeight = Math.max(0, (document._lastInnerHeight || window.innerHeight) - window.innerHeight);
  }
  if(keyboardHeight > 0){
    chat.style.paddingBottom = (keyboardHeight + 84) + 'px';
    setTimeout(()=> scrollChatToBottom(false), 60);
  } else {
    chat.style.paddingBottom = '';
    scrollChatToBottom();
  }
}
document._lastInnerHeight = window.innerHeight;
window.addEventListener('resize', ()=> { document._lastInnerHeight = Math.max(document._lastInnerHeight || 0, window.innerHeight); });
if(window.visualViewport) window.visualViewport.addEventListener('resize', onViewportResize);
else window.addEventListener('resize', onViewportResize);
msg.addEventListener('focus', ()=> { setTimeout(()=> { onViewportResize(); scrollChatToBottom(false); }, 60); });
msg.addEventListener('blur', ()=> { setTimeout(()=> onViewportResize(), 60); });

/* rooms refresh polling & snapshot */
async function refreshRoomsEvery(interval=30000){
  await loadRooms();
  setTimeout(()=>refreshRoomsEvery(interval), interval);
}
refreshRoomsEvery();

onSnapshot(collection(db,'rooms'), snap => {
  roomList.innerHTML = ''; roomListSidebar.innerHTML = ''; roomListMobile.innerHTML = '';
  snap.forEach(d => renderRoomEntry(d.id));
});

/* utility helpers */
function escapeHtml(s){
  if(!s && s !== 0) return '';
  return String(s).replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); });
}
function escapeAttr(s){ return (s||'').replace(/"/g,'&quot;'); }

/* linkify - turns URLs into anchors */
function linkify(text){
  const urlRegex = /((https?:\/\/|www\.)[^\s<]+)/g;
  return text.replace(urlRegex, (url) => {
    let href = url;
    if(!href.match(/^https?:\/\//)) href = 'http://' + href;
    return `<a href="${escapeAttr(href)}" target="_blank" rel="noopener noreferrer">${escapeHtml(url)}</a>`;
  });
}

/* scroll to bottom button */
function scrollChatToBottom(instant = true){
  try{
    if(instant) chat.scrollTop = chat.scrollHeight;
    else chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
  }catch(e){}
  updateScrollButtonVisibility();
}
chat.addEventListener('scroll', updateScrollButtonVisibility);
function updateScrollButtonVisibility(){
  const atBottom = chat.scrollHeight - chat.scrollTop - chat.clientHeight < 140;
  if(!atBottom) scrollBottomBtn.style.display = 'block';
  else scrollBottomBtn.style.display = 'none';
}
scrollBottomBtn.addEventListener('click', ()=> scrollChatToBottom(false));

/* message delete/edit functions */
async function deleteMessage(id, m){
  if(m.name !== nick){ alert('You can only delete your own messages.'); return; }
  if(!confirm('Delete this message?')) return;
  try{ await deleteDoc(doc(db,'rooms',room,'messages',id)); }catch(e){ console.error('delete failed', e); }
}
function startEditMessage(id, m){
  if(m.name !== nick){ alert('You can only edit your own messages.'); return; }
  editingMessageId = id;
  msg.value = m.text || '';
  msg.focus();
}

/* msg menu hide utility */
function hideMsgMenu(){ msgMenu.classList.remove('show'); msgMenu.style.left=''; msgMenu.style.top=''; }

/* show seen popup hide */
function hideSeenPopup(){ seenPopup.classList.remove('show'); }

/* Profile button on lobby header opens own profile */
lobbyUserBtn.addEventListener('click', () => {
  const session = localStorage.getItem('session') || nickInput.value;
  showProfile(session);
});

/* notification helper */
document.addEventListener('visibilitychange', ()=> {
  if(!document.hidden) lastMessageTime = Date.now();
  // update presence lastSeen
  if(room && nick) setDoc(doc(db,'rooms',room,'presence',nick), { lastSeen: serverTimestamp(), color: nickColorInput.value }, { merge: true }).catch(()=>{});
});

/* ensure mobile drawer starts closed on load */
if(isMobile){
  mobileOverlay.style.display = 'none';
  mobileDrawer.style.display = 'none';
  mobileDrawer.classList.remove('show');
  mobileOverlay.classList.remove('show');
  updateOpenLobbyBtnVisibility();
} else {
  enforceDesktopLobby();
  updateOpenLobbyBtnVisibility();
}

/* update nick editability on load */
updateNickEditable();

</script>
</body>
</html>
